# Maintaining the History of the Search

<img  src="https://github.com/user-attachments/assets/53333ee5-cfd1-4944-a619-4651c20fed5b" width = "400px" />


## Overview

We know how to use search to explore a search tree and find the goal state. We also know how to use uniform-cost search to find a solution with minimum total cost. However, we've only considered *discovering* that the solution exists. We also need to **return the sequence of states** on the solution path, so we can construct the plan of actions that moves from the start state to the goal.

The strategy is to use an additional structure to keep track of the **parent** of each node in the search tree. When we create the successors of a node, we'll include the parent state as part of the node's information. Then, when a node is marked as visited, record its official parent in the map. When we reach the goal, we can then recover the sequence of intermediate states by following the chain of parents backwards to the start.

## Pseudocode

```
Uniform Cost Search with Path Tracking

input:
    initial state i
    goal state g
    successors function  // returns list of (next state, step cost) tuples

output:
    path from i to g if reachable, failure otherwise

initialize empty priority queue frontier (ordered by cost, lowest first)
initialize empty map parent  // maps each state to its predecessor

// Begin with the starting state at cost 0, no parent
frontier.insert(i, null, 0)

while frontier is not empty {

    // Choose the state with the lowest cumulative cost
    (x, x_parent, cost) = frontier.pop_min()

    // Check if x has already been visited; if so, don't expand it again
    if visited[x] {
        continue
    }

    // We're now visiting x, so mark it and record its true parent
    visited[x] = True
    parent[x] = x_parent

    // If x is the goal state, reconstruct and return the path
    if x == g {
        path = reconstruct_path(x, parent)
        output path and stop
    }

    // Generate successors of x
    s = successors(x)

    // Insert successor states into frontier with cumulative cost
    //
    // x is included as the parent of j
    for (j, step_cost) in s {
        frontier.insert(j, x, cost + step_cost)
    }
}

// If the loop ends, the state space was exhausted without reaching the goal
output failure and stop
```

The `reconstruct_path` function works backwards through the `parent` structure:
```
reconstruct_path(goal, parent) {
    path = []
    current = goal
    
    while current is not null {
        path.prepend(current)
        current = parent[current]
    }
    
    return path
}
```

## Example: the eight-puzzle

<img src="https://www.aiai.ed.ac.uk/~gwickler/images/8-puzzle-states.png" width="400px"/>

*From [The Artificial Intelligence Applications Institute](https://www.aiai.ed.ac.uk/~gwickler/eightpuzzle-uninf.html). Follow the link for a playable version.*

The eight-puzzle is sliding block game using a 3x3 grid. There are eight tiles numbered 1-8 and one tile missing. The goal is slide the blocks and arrange the numbers in sorted order, with the empty space at the front (or in some versions, at the end). It's a classic AI search demonstration problem. Larger variants with 15 or more blocks exist.

This is another case where deciding to use search is not the challenge. Instead, the problem is coming up with a representation for the solution, generating successors, and keeping track of the sequence of states. For this example, let's combine the path tracking idea with iterative deepening.

The state will be a tuple of the values 0-8 recording the number at each position of the grid in row order. For example, the starting state of the puzzle above would be `(8, 0, 6, 5, 4, 7, 2, 3, 1)`.

The hardest part is generating successors. The function below was generated by Claude and uses a clever approach. The basic strategy is to consider the possible moves of the 0 value. That is, instead of trying to model sliding numbers *into* the blank space and leaving a new blank space behind, think about *exchanging* the blank space with each of its neighbors. The function uses the `moves` map to record all of the indices that can be exchanged with each blank position. For example, if the blank is at index 1 (the top-middle position), it could be exchanged with 0 (top-left), 2 (top-right), or 4 (center-middle).
```
def get_successors(state):
    """
    Generate all valid successor states from the current state.
    Returns a list of states reachable by sliding one tile into the blank.
    """
    successors = []
    state = list(state)
    blank_idx = state.index(0)
    
    # Define possible moves based on blank position
    # Maps each position to the positions it can swap with
    moves = {
        0: [1, 3],
        1: [0, 2, 4],
        2: [1, 5],
        3: [0, 4, 6],
        4: [1, 3, 5, 7],
        5: [2, 4, 8],
        6: [3, 7],
        7: [4, 6, 8],
        8: [5, 7]
    }
    
    for swap_idx in moves[blank_idx]:
        new_state = state.copy()
        new_state[blank_idx], new_state[swap_idx] = new_state[swap_idx], new_state[blank_idx]
        successors.append(tuple(new_state))
    
    return successors
```

### Solution

The solution below was generated by Claude from the pseudocode and problem description. Pay the most attention to the actual iterative deepening method, which should look familiar to you by this point.

```
"""
Eight Puzzle Solver using Iterative Deepening Search with Path Tracking

The 8-puzzle is represented as a tuple of 9 elements (0-8), where 0 represents
the blank tile. Index positions correspond to:
    0 | 1 | 2
    ---------
    3 | 4 | 5
    ---------
    6 | 7 | 8
"""


def get_successors(state):
    """
    Generate all valid successor states from the current state.
    Returns a list of states reachable by sliding one tile into the blank.
    """
    successors = []
    state = list(state)
    blank_idx = state.index(0)
    
    # Define possible moves based on blank position
    # Maps each position to the positions it can swap with
    moves = {
        0: [1, 3],
        1: [0, 2, 4],
        2: [1, 5],
        3: [0, 4, 6],
        4: [1, 3, 5, 7],
        5: [2, 4, 8],
        6: [3, 7],
        7: [4, 6, 8],
        8: [5, 7]
    }
    
    for swap_idx in moves[blank_idx]:
        new_state = state.copy()
        new_state[blank_idx], new_state[swap_idx] = new_state[swap_idx], new_state[blank_idx]
        successors.append(tuple(new_state))
    
    return successors


def reconstruct_path(goal, parent):
    """
    Reconstruct the path from initial state to goal by following parent pointers.
    """
    path = []
    current = goal
    
    while current is not None:
        path.append(current)
        current = parent[current]
    
    path.reverse()
    return path


def iterative_deepening_search(initial, goal):
    """
    Iterative Deepening Search with path tracking.
    
    Args:
        initial: Starting state (tuple of 9 integers)
        goal: Goal state (tuple of 9 integers)
    
    Returns:
        List of states from initial to goal if solution exists, None otherwise
    """
    # Check if already at goal
    if initial == goal:
        return [initial]
    
    depth_limit = 0
    
    while True:
        # Initialize frontier as stack: (state, depth, parent_state)
        frontier = [(initial, 0, None)]
        visited = set()
        parent = {}
        
        while frontier:
            state, depth, state_parent = frontier.pop()
            
            # Skip if already visited
            if state in visited:
                continue
            
            # Mark as visited and record parent
            visited.add(state)
            parent[state] = state_parent
            
            # Check for goal
            if state == goal:
                return reconstruct_path(state, parent)
            
            # Expand if within depth limit
            if depth < depth_limit:
                for successor in get_successors(state):
                    frontier.append((successor, depth + 1, state))
        
        depth_limit += 1
        
        # Safety limit to prevent infinite loops on unsolvable puzzles
        if depth_limit > 50:
            return None


def print_state(state):
    """Pretty print a puzzle state."""
    for i in range(0, 9, 3):
        row = [str(x) if x != 0 else ' ' for x in state[i:i+3]]
        print(' | '.join(row))
        if i < 6:
            print('---------')


def print_solution(path):
    """Print the solution path with step numbers."""
    if path is None:
        print("No solution found.")
        return
    
    print(f"Solution found in {len(path) - 1} moves:\n")
    for i, state in enumerate(path):
        print(f"Step {i}:")
        print_state(state)
        print()


if __name__ == "__main__":
    goal = (0, 1, 2, 3, 4, 5, 6, 7, 8)
    initial = (8, 0, 6, 5, 4, 7, 2, 3, 1)
    
    path = iterative_deepening_search(initial, goal)
    print_solution(path)
```

